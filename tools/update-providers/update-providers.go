//go:build buildtools

// TODO: the current code is confusing and I'm not sure it's
// error resilient or helpful in case something is not as
// expected. Probably better to rewrite this.

package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/printer"
	"go/token"
	"log"
	"os"
	"os/exec"
	"regexp"
	"strings"
	"unicode"

	"github.com/gnulinuxindia/internet-chowkidar/utils"
)

const packageName string = "github.com/goalistdeveloper/go-template"
const header string = "// Code generated by tools/update-providers.go; DO NOT EDIT."

func main() {
	// handlers
	updateProviders(UpdateProvidersProps{
		providerPkg:      "api",
		constructorPkg:   "handler",
		kind:             "handler",
		pluralKind:       "handlers",
		dir:              "api/handler",
		constructorsPath: "api/handler/constructors.go",
		providerPath:     "api/provider.go",
	})

	// service
	updateProviders(UpdateProvidersProps{
		providerPkg:      "di",
		constructorPkg:   "service",
		kind:             "service",
		pluralKind:       "services",
		dir:              "pkg/domain/service",
		constructorsPath: "pkg/domain/service/constructors.go",
		providerPath:     "pkg/domain/provider/service.go",
	})

	// repository
	updateProviders(UpdateProvidersProps{
		providerPkg:      "di",
		constructorPkg:   "repository",
		kind:             "repository",
		pluralKind:       "repositories",
		dir:              "pkg/domain/repository",
		constructorsPath: "pkg/domain/repository/constructors.go",
		providerPath:     "pkg/domain/provider/repository.go",
	})
}

type UpdateProvidersProps struct {
	providerPkg      string
	constructorPkg   string
	kind             string
	pluralKind       string
	dir              string
	constructorsPath string
	providerPath     string
}

func updateProviders(props UpdateProvidersProps) {
	kind := UpperFirstChar(props.kind)
	pluralKind := UpperFirstChar(props.pluralKind)

	interfaceNameRe := regexp.MustCompile(`[a-zA-Z1-9]+` + kind)

	files, err := os.ReadDir(props.dir)
	if err != nil {
		fmt.Println("Error reading directory:", err)
		return
	}

	var definitions []string

	constructorDecls := fmt.Sprintf(`%s
package %s
`, header, props.constructorPkg)

	var mockUsingDefs []string

	for _, file := range files {
		if !file.IsDir() {
			filePath := props.dir + "/" + file.Name()

			byteContent, err := os.ReadFile(filePath)
			if err != nil {
				fmt.Println("Error reading file:", filePath, err)
				continue
			}
			src := string(byteContent)

			usesMock := false
			if strings.SplitN(src, "\n", 2)[0] == "//use:mock" {
				usesMock = true
			}

			file, err := parser.ParseFile(token.NewFileSet(), "", src, 0)
			if err != nil {
				log.Fatal("Error parsing file: ", err)
			}

			var definition string
			var provider string
			var implStruct string
			var dependencies [][]string

			definitionFound := false
			providerFound := false
			implStructFound := false

			ast.Inspect(file, func(n ast.Node) bool {
				if !definitionFound {
					ts, ok := n.(*ast.TypeSpec)
					if ok {
						_, ok = ts.Type.(*ast.InterfaceType)
						if ok {
							if interfaceNameRe.MatchString(ts.Name.Name) {
								definitionFound = true
								definition = ts.Name.Name
								provider = "Provide" + definition
								implStruct = LowerFirstChar(definition) + "Impl"
								definitions = append(definitions, definition)

								if usesMock {
									mockUsingDefs = append(mockUsingDefs, definition)
								}
							}
						}
					}
				}

				if !providerFound {
					fd, ok := n.(*ast.FuncDecl)
					if ok {
						if fd.Name.Name == provider {
							providerFound = true
						}
					}
				}

				if !implStructFound {
					ts, ok := n.(*ast.TypeSpec)
					if ok {
						st, ok := ts.Type.(*ast.StructType)
						if ok {
							if ts.Name.Name == implStruct {
								implStructFound = true

								for _, field := range st.Fields.List {
									if len(field.Names) == 0 {
										// embedded field, continue
										fmt.Printf("%s: constructor gen: ignoring embedded field in impl struct definition: '%s'\n", definition, field.Type)
										continue
									}

									var typeNameBuf bytes.Buffer
									err := printer.Fprint(&typeNameBuf, token.NewFileSet(), field.Type)
									if err != nil {
										fmt.Println("Error in printing type:", err)
										continue
									}

									typeName := typeNameBuf.String()
									dependencies = append(dependencies, []string{LowerFirstChar(field.Names[0].Name), typeName})
								}
							}
						}
					}
				}

				return true
			})

			if definitionFound {
				if !providerFound && implStructFound {
					var args string
					var assmts string

					for _, dep := range dependencies {
						name := dep[0]
						typeName := dep[1]
						args += fmt.Sprintf("%s %s,\n", name, typeName)
						assmts += fmt.Sprintf("\n\t\t%s: %s,\n", name, name)
					}

					constructorDecls += fmt.Sprintf("func %s(\n%s) %s { return &%s{%s}\n}\n\n", provider, args, definition, implStruct, assmts)
					fmt.Printf("%s: constructor gen: generated constructor", definition)
					if usesMock {
						fmt.Printf(" (will be mocked in tests)\n")
					} else {
						fmt.Printf("\n")
					}
				} else if !providerFound && !implStructFound {
					panic(fmt.Errorf(kind+" found, but impl struct '%s' not found", implStruct))
				} else {
					fmt.Printf("%s: constructor gen: constructor already present\n", definition)
				}
			}
		}
	}

	type DefinitionSet struct {
		name         string
		lcName       string
		providerName string
		usesMock     bool
	}

	definitionSets := utils.MapOver(definitions, func(def string) DefinitionSet {
		return DefinitionSet{
			name:         def,
			lcName:       LowerFirstChar(def),
			providerName: "Provide" + def,
			usesMock:     utils.Contains(mockUsingDefs, def),
		}
	})

	var finalDefinitionSet string
	var finalStructs string
	var finalMockStructs string
	var finalMockDefinitionSet string
	var finalMockProviders string

	for _, defSet := range definitionSets {
		finalDefinitionSet += fmt.Sprintf("\n\t%s,", props.constructorPkg+"."+defSet.providerName)
		finalStructs += fmt.Sprintf("\n\t%s.%s", props.constructorPkg, defSet.name)

		if defSet.usesMock {
			mockProviderFn := "ProvideMock" + defSet.name
			mockCreatorFn := "mock_" + props.constructorPkg + ".NewMock" + defSet.name
			finalMockProviders += fmt.Sprintf("\nfunc %s(ctrl *gomock.Controller) %s {\nMock%sInstance.Mock%s = %s(ctrl)\n return Mock%sInstance.Mock%s\n}", mockProviderFn, props.constructorPkg+"."+defSet.name, pluralKind, defSet.name, mockCreatorFn, pluralKind, defSet.name)
			finalMockDefinitionSet += fmt.Sprintf("\n\t%s,", mockProviderFn)
			finalMockStructs += fmt.Sprintf("\n\t*mock_%s.Mock%s", props.constructorPkg, defSet.name)
		} else {
			finalMockDefinitionSet = finalDefinitionSet
		}
	}

	wireTemplate :=
		fmt.Sprintf(`%[1]s
package %[2]s

import (
	"github.com/google/wire"
)

type %[4]s struct {%[5]s
}

type Mock%[4]s struct {%[9]s
}

var %[3]sSet = wire.NewSet(%[6]s
	wire.Struct(new(%[4]s), "*"),
)

%[7]s

var Mock%[4]sInstance Mock%[4]s = Mock%[4]s{}

var Mock%[3]sSet = wire.NewSet(%[8]s
	wire.Struct(new(%[4]s), "*"),
	wire.Struct(new(Mock%[4]s), "*"),
)
`,
			header,                 /* 1 */
			props.providerPkg,      /* 2 */
			kind,                   /* 3 */
			pluralKind,             /* 4 */
			finalStructs,           /* 5 */
			finalDefinitionSet,     /* 6 */
			finalMockProviders,     /* 7 */
			finalMockDefinitionSet, /* 8 */
			finalMockStructs,       /* 9 */
		)

	WriteSource(props.constructorsPath, constructorDecls)
	WriteSource(props.providerPath, wireTemplate)
}

func LowerFirstChar(s string) string {
	if len(s) == 0 {
		return s
	}

	f := unicode.ToLower(rune(s[0]))
	return string(f) + s[1:]
}

func UpperFirstChar(s string) string {
	if len(s) == 0 {
		return s
	}

	f := unicode.ToUpper(rune(s[0]))
	return string(f) + s[1:]
}

func WriteSource(path string, source string) {
	formattedSource, err := format.Source([]byte(source))
	if err != nil {
		panic(fmt.Sprint("Error formatting code to write to '"+path+"':\n"+source+"\n", err))
	}

	err = os.WriteFile(path, []byte(formattedSource), 0600)
	if err != nil {
		panic(fmt.Sprint("Error writing '"+path+"':", err))
	}

	cmd := exec.Command("goimports", "-w", path)
	err = cmd.Run()
	if err != nil {
		panic(fmt.Sprint("Error running goimports on '"+path+"':", err))
	}
}
